(define (cv coinIndex)
  (cond ((= coinIndex 1) 1)
        ((= coinIndex 2) 5)
        ((= coinIndex 3) 10)
        ((= coinIndex 4) 25)
        (else 50)))

(define (cc n v)
  (cond ((= n 0) 0)
        ((< v 0) 0)
        ((= v 0) 1)
        (else (+
               (cc (- n 1) v)
               (cc n (- v (cv n))))
              )))

(cc 5 11)
(+ (cc 4 11) (cc 5 -39))
(+ (+ (cc 3 11) (cc 4 -13)) 0)
(+ (+ (+ (cc 2 11) (cc 3 1)) 0) 0)
(+ (+ (+ (+ (cc 1 11) (cc 2 6)) (+ (cc 2 1) (cc 3 -9))) 0) 0)
(+ (+ (+ (+ (+ (cc 0 11) (cc 1 10)) (+ (cc 1 6) (cc 2 1))) (+ (+ (cc 1 1) (cc 2 -4)) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ (cc 0 10) (cc 1 9))) (+ (+ (cc 0 6) (cc 1 5)) (+ (cc 1 1) (cc 2 -4)))) (+ (+ (cc 1 1) 0) 0)) 0) 0)
(+ (+ (+ (+ (+ 0 (+ 0 (+ 0 (cc 1 8)))) (+ (+ 0 (+ 0 (cc 1 4))) (+ (+ 0 (cc 1 0)) 0))) (+ (+ (+ 0 (cc 1 0)) 0) 0)) 0) 0)
;; space:n time:2^n
;;cc 5 11
;;   |
;;cc 4 11 + -------------------------------------- cc 5 -39
;;   |
;;cc 3 11 + -------------------------------------- cc 4 -14
;;   |
;;cc 2 11 + -------------------------------------- cc 3 1
;;   |                                                |
;;cc 1 11 + ----------- cc 2 6                     cc 2 1 + -------------cc 3 -9
;;   |                     |
;;cc 0 11 + cc 1 10     cc 1 6 + cc 2 1            ......
;;.......
;; 在应用序里
;; 空间（计算深度），考虑最左侧纵向长度决定，横向长度仅在计算的时候展开
;; 应该是O(n)
;; 时间（计算次数），考虑最右侧结构，上面的结构接近二叉树，
;; 应该是0(2^n)
