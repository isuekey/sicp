
(defun add-interval (x y)
    (make-interval (+ (lower-bound x) (lower-bound y))
                   (+ (upper-bound x) (upper-bound y))))


(defun div-interval (x y)
  (mul-interval x (make-interval (/ 1.0 (upper-bound y))
                                 (/ 1.0 (lower-bound y)))))

(defun make-interval (a b)
  (if (< a b)
      (cons a b)
    (cons b a)))
(defun lower-bound (interval) (car interval))
(defun upper-bound (interval) (cdr interval))
(defun mul-interval (x y)
  (let ((lx (lower-bound x))
        (ux (upper-bound x))
        (ly (lower-bound y))
        (uy (upper-bound y)))
    (cond ((not (< lx 0))
           (cond ((not (< ly 0)) (make-interval (* lx ly) (* ux uy)))
                 ((not (> uy 0)) (make-interval (* ux ly) (* lx uy)))
                 (t (make-interval (* ux ly) (* ux uy)))))
          ((not (> ux 0))
           (cond ((not (< ly 0)) (make-interval (* lx uy) (* ux ly)))
                 ((not (> uy 0)) (make-interval (* ux uy) (* lx ly)))
                 (t (make-interval (* lx uy) (* lx ly)))))
          (t
           (cond ((not (< ly 0)) (make-interval (* lx uy) (* ux uy)))
                 ((not (> uy 0)) (make-interval (* ux ly) (* lx ly)))
                 (t (let ((m1 (/ (+ lx ux) 2))
                          (m2 (/ (+ ly uy) 2)))
                      (cond ((< m1 0)
                             (cond ((< m2 0)
                                    (let ((lxuy (* lx uy))
                                          (uxly (* ux ly)))
                                      (cond ((< lxuy uxly) (make-interval lxuy (* lx ly)))
                                            (t (make-interval uxly (* lx ly))))))
                                   (t
                                    (let ((lxly (* lx ly))
                                          (uxuy (* ux uy)))
                                      (cond ((< lxly uxuy) (make-interval (* lx uy) uxuy))
                                            (t (make-interval (* lx uy) lxly)))))))
                            (t
                             (cond ((< m2 0)
                                    (let ((lxly (* lx ly))
                                          (uxuy (* ux uy)))
                                      (cond ((< lxly uxuy) (make-interval (* ux ly) uxuy))
                                            (t (make-interval (* ux ly) lxly)))))
                                   (t
                                    (let ((lxuy (* lx uy))
                                          (uxly (* ux ly)))
                                      (cond ((< lxuy uxly) (make-interval lxuy (* ux uy)))
                                            (t (make-interval uxly (* ux uy))))))))))))))))


(defun sub-interval (x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))
(defun print-interval (i)
  (princ #\Newline)
  (princ "(")
  (princ (lower-bound i))
  (princ ", ")
  (princ (upper-bound i))
  (princ ")"))
;;; 使用抽象证明的应该考虑c,w的方式

(defvar r1 (make-interval 36 44))
(defvar r2 (make-interval 40 60))

(defun part1 (x y)
  (div-interval (mul-interval x y)
                (add-interval x y)))

(defun part2 (x y)
  (let ((one (make-interval 1 1)))
    (div-interval one
                  (add-interval (div-interval one x)
                                (div-interval one y)))))

(print-interval r1)
(print-interval r2)
(defvar pp1 (part1 r1 r2))
(defvar pp2 (part2 r1 r2))
(print-interval pp1)
(print-interval pp2)
        
(defun center (i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(defun width (i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(print (center pp1))
(princ (width pp1))
(print (center pp2))
(princ (width pp2))
