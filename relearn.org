* 第一章 程序设计基本元素
** 程序
*** 基本程序内容的语法
*** 基本程序内容的组合的方法
*** 抽象的方法
** 程序执行解析
*** 代换模型
*** 应用序
*** 正则序
*** shceme是应用序
** 程序表达式：普通式与特殊式
*** 普通式 先求出所有参数式的值，再用操作式的值来操作
*** 特殊式 按照特定方式求算程序表达式的值
** 计算过程
*** 递归计算：
**** 线性递归计算（一般是应用序）
**** 其他的递归计算（一般是正则序）
*** 迭代计算
* 第二章 数据抽象引导
** 前言
*** 数据抽象将逻辑的处理过程与处理内容隔离开，是有力的设计方法
*** 数据抽象将帮助我们在程序的不同部分之间建立抽象屏障。
*** 复合数据的关键思想是闭包的概念
*** 复合数据的第二个关键思想是成为以混合与匹配的方式组合程序过程的方便界面
*** 符号表达式进一步扩大表达能力
** 2.1 数据抽象引导
过程抽象将程序过程语义化，隐藏了过程细节
数据抽象将数据细节语义化，隐藏了数据细节
*** 实例：有理数算术运算
**** 从有序对开始 cons car cdr
**** 有理数 表示
*** 抽象屏障
抽象屏障可以推迟决策时间，有助于程序的设计
*** 数据的含义（数据意味着啥）
这里再次强调了序对是个抽象概念不是所谓的基本过程。并举出了一个例证
**** 数据的过程性表示在程序设计中有重要地位：消息传递
*** 扩展练习：区间算术
练习区间的加乘除运算
** 2.2 层次性数据和闭包性质
*** 2.2.1序列的表示
**** 数据闭包性质操作：
 通过这个操作组合起数据对象得到的结果本身还可以通过同样的操作再进行组合
***** 这个定义来自抽象代数
**** list操作（在这个社区里list称为表）
 (list 1 2 3 4) 等价于
 (cons 1 (cons 2 (cons 3 (cons 4 nil))))
**** null?操作，检查cons不为空
**** 对表的映射 
 可以抽象出一个高级操作map.
***** 它不仅代表了一种公共模式
***** 还建立一种处理表的高层抽象
***** 并不是说具体计算过程有差异(复杂度没有变化)，
***** 而是我们思考问题的方式
*** 2.2.2 层次性结构
很自然的可以让元素也是表（list，在其他语言中容易跟map混性。
list可以理解为key是有序数字的map，进而有一些额外特性。）
**** 使用list作为元素，形成了一种树形结构
 如果只用cons表示，显然使用一种二叉树
 如果用list表示可以是所有（我猜的）种树形结构。
 但是list又cons的语法糖衣
 所以所有树形结构都是二叉树的特例形式
**** 递归是处理数结构的一种很自然的工具
**** pair? 检查是否是序对
**** 对树的映射
map是一种强力的抽象。map与递归组合起来也是处理树的强力抽象
*** 2.2.3 序列作为一种约定的界面
程序都是对数据进行加工以得到期望的数据，那么对输入数据格式进行约定
是一种强力的设计原则。
那么使用常见的数据结构，并在此之上进行编程就是一种强力的编程习惯。
进而熟悉所用语言中常见的数据结构，并对之上的操作方法烂熟于心，
就能够极大的提高所用语言的编程能力。
**** sum-odds-squares 过程
***** 遍历树的树叶
***** 过滤它们，找到其中的奇数
***** 求算平方
***** 累积求和，从0开始
**** even-fibs 过程
***** 遍历0到n
***** 计算每个对应的斐波那契数
***** 过滤他们选出他们的偶数
***** 用cons累积结果，从空表开始
**** 序列操作：信息流的方式处理问题（流水线方式加工）
**** 嵌套映射
1<=j < i <=n中 i+j为素数的组合
*** 2.2.4 一个图形语言
描述一种语言应该将注意力集中在语言的基本原语，组合手段以及抽象手段。
这是个纯粹抽象过程，无法实际调试的。不过可以用假的draw过程来检测。
**** 图形语言
**** 高阶操作
**** 框架
用三个向量描述：基准向量和两个角向量
***** 基准向量描述的是框架基准点相对于平面上某个绝对基准点的偏移量
***** 角向量描述了框架的角相对于框架基准点的偏移量。如果角向量正交，就是矩形，否则是平行四边形
向量v=(x,y)映射到框架中
Origin(Frame) + x*Edge1(Frame) + y*Edge2(Frame)
按照逆时针顺序定义的edge1，edge2
**** 画家 (painter frame)，是画家在框架上绘画，而不是框架了画家
**** 画家的变换和组合
对画家的过程根本不需要知道画家的实际效果
**** 强健设计的语言层次
引入了分层设计的概念
** 2.3 符号数据
*** 2.3.1引号 用于描述是一个符号而不是值
(define a 1)
(define b 2)
(list a b) 
(1 2)
(list 'a b)
 (a 2)
(car '(a b c))
a
(cdr '(a b c))
(b c)
**** '(a b c) 是 (quote (a b c))的语法糖衣，返回符号表。同理 (quote a) <=> 'a
*** 2.3.2实例：符号求导
**** 对抽象数据的求导程序
dc/dx = 0 其中c与x无关
dx/dx = 1
d(u+v)/dx = du/dx + dv/dx
d(uv)/dx = u(dv/dx)+v(du/dx)
**** 代数表达式的表示
代数化简存在一个问题，某些用途的最简式，未必是其他用途的最简式
*** 2.3.3实例：集合的表示
(element-of-set? ele set) 元素ele是否在集合set中
(adjoin-set ele set) 向集合set中增加元素ele
(union-set set1 set2) 合并两个集合set1、set2。
(intersection-set set1 set2) 集合set1、set2的交集。
**** 集合作为未排序的表
并集与交集的处理复杂度约为O(N^2)，有人较真的话O(N*M)，
可这种表示其实是故作聪明。请正确理解复杂度的概念。
**** 集合作为排序的表
为了加速，可以改变集合的表示方式，比如按照升序排列。因为排序之后的表
我们可以分治处理。原来的element-of-set?由O(N)，改为O(logN)
反映到并集、交集计算的时候差异更加明显O(NlogN)
就算不用分治，在计算并集与交集的时候也会有很多优势，
因为不需要两个的全表检查。在递归的时候，可以缩小两个表。
**** 集合作为二叉树
**** 集合与信息检索
现实很复杂，有产品级的需求，有项目级的需求，有演示级的需求，
对应不同的数据量，健壮程度，响应速度，
***  2.3.4 实例：Huffman编码树
**** 定长编码：ASCII
**** 变长编码：莫斯密码，utf-8编码。困难：不知道一个字符的结束
***** 使用间隔符
***** 完整编码不是其他编码的开始（前缀码）
| A |   B |    C |    D |    E |    F |    G |    H |
| 0 | 100 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
一般而言使用变长前缀码处理编码消息，使得长度短的应对频率高，
可以显著的节约空间。一种特定方式就是Huffman编码
***** 一个Huffman树可以表示为一个二叉树
树叶是北面吗的符号，每个非叶子节点表示一个结合，包含其下的所有叶子
并且每个节点有权重，非叶节点为其下所有叶子权重之和。
权重在编码与解码中没用，但是有助于构造树
***** 构造
***** 解码 一个0/1的表与Huffman树为参数
***** 带权重元素的集合
***** 
