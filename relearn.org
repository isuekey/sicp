* 前言
吐槽一下，
* 第一章 程序设计基本元素
** 程序
*** 基本程序内容的语法
*** 基本程序内容的组合的方法
*** 抽象的方法
** 程序执行解析
*** 代换模型
*** 应用序
*** 正则序
*** shceme是应用序
** 程序表达式：普通式与特殊式
*** 普通式 先求出所有参数式的值，再用操作式的值来操作
*** 特殊式 按照特定方式求算程序表达式的值
** 计算过程
*** 递归计算：
**** 线性递归计算（一般是应用序）
**** 其他的递归计算（一般是正则序）
*** 迭代计算
* 第二章 数据抽象引导
** 前言
*** 数据抽象将逻辑的处理过程与处理内容隔离开，是有力的设计方法
*** 数据抽象将帮助我们在程序的不同部分之间建立抽象屏障。
*** 复合数据的关键思想是闭包的概念
*** 复合数据的第二个关键思想是成为以混合与匹配的方式组合程序过程的方便界面
*** 符号表达式进一步扩大表达能力
** 2.1 数据抽象引导
过程抽象将程序过程语义化，隐藏了过程细节
数据抽象将数据细节语义化，隐藏了数据细节
*** 实例：有理数算术运算
**** 从有序对开始 cons car cdr
**** 有理数 表示
*** 抽象屏障
抽象屏障可以推迟决策时间，有助于程序的设计
*** 数据的含义（数据意味着啥）
这里再次强调了序对是个抽象概念不是所谓的基本过程。并举出了一个例证
**** 数据的过程性表示在程序设计中有重要地位：消息传递
*** 扩展练习：区间算术
练习区间的加乘除运算
** 2.2 层次性数据和闭包性质
*** 2.2.1序列的表示
**** 数据闭包性质操作：
 通过这个操作组合起数据对象得到的结果本身还可以通过同样的操作再进行组合
***** 这个定义来自抽象代数
**** list操作（在这个社区里list称为表）
 (list 1 2 3 4) 等价于
 (cons 1 (cons 2 (cons 3 (cons 4 nil))))
**** null?操作，检查cons不为空
**** 对表的映射 
 可以抽象出一个高级操作map.
***** 它不仅代表了一种公共模式
***** 还建立一种处理表的高层抽象
***** 并不是说具体计算过程有差异(复杂度没有变化)，
***** 而是我们思考问题的方式
*** 2.2.2 层次性结构
很自然的可以让元素也是表（list，在其他语言中容易跟map混性。
list可以理解为key是有序数字的map，进而有一些额外特性。）
**** 使用list作为元素，形成了一种树形结构
 如果只用cons表示，显然使用一种二叉树
 如果用list表示可以是所有（我猜的）种树形结构。
 但是list又cons的语法糖衣
 所以所有树形结构都是二叉树的特例形式
**** 递归是处理数结构的一种很自然的工具
**** pair? 检查是否是序对
**** 对树的映射
map是一种强力的抽象。map与递归组合起来也是处理树的强力抽象
*** 2.2.3 序列作为一种约定的界面
程序都是对数据进行加工以得到期望的数据，那么对输入数据格式进行约定
是一种强力的设计原则。
那么使用常见的数据结构，并在此之上进行编程就是一种强力的编程习惯。
进而熟悉所用语言中常见的数据结构，并对之上的操作方法烂熟于心，
就能够极大的提高所用语言的编程能力。
**** sum-odds-squares 过程
***** 遍历树的树叶
***** 过滤它们，找到其中的奇数
***** 求算平方
***** 累积求和，从0开始
**** even-fibs 过程
***** 遍历0到n
***** 计算每个对应的斐波那契数
***** 过滤他们选出他们的偶数
***** 用cons累积结果，从空表开始
**** 序列操作：信息流的方式处理问题（流水线方式加工）
**** 嵌套映射
1<=j < i <=n中 i+j为素数的组合
*** 2.2.4 一个图形语言
描述一种语言应该将注意力集中在语言的基本原语，组合手段以及抽象手段。
这是个纯粹抽象过程，无法实际调试的。不过可以用假的draw过程来检测。
**** 图形语言
**** 高阶操作
**** 框架
用三个向量描述：基准向量和两个角向量
***** 基准向量描述的是框架基准点相对于平面上某个绝对基准点的偏移量
***** 角向量描述了框架的角相对于框架基准点的偏移量。如果角向量正交，就是矩形，否则是平行四边形
向量v=(x,y)映射到框架中
Origin(Frame) + x*Edge1(Frame) + y*Edge2(Frame)
按照逆时针顺序定义的edge1，edge2
**** 画家 (painter frame)，是画家在框架上绘画，而不是框架了画家
**** 画家的变换和组合
对画家的过程根本不需要知道画家的实际效果
**** 强健设计的语言层次
引入了分层设计的概念
** 2.3 符号数据 
从这里开始就越来越抽象了。之前也是抽象（数学公式吗），
但是现在程序实现抽象程序。就是写一些过程，操作另外一些过程。
这样就不是很直观了。
*** 2.3.1引号 用于描述是一个符号而不是值
(define a 1)
(define b 2)
(list a b) 
(1 2)
(list 'a b)
 (a 2)
(car '(a b c))
a
(cdr '(a b c))
(b c)
**** '(a b c) 是 (quote (a b c))的语法糖衣，返回符号表。同理 (quote a) <=> 'a
*** 2.3.2实例：符号求导
**** 对抽象数据的求导程序
dc/dx = 0 其中c与x无关
dx/dx = 1
d(u+v)/dx = du/dx + dv/dx
d(uv)/dx = u(dv/dx)+v(du/dx)
**** 代数表达式的表示
代数化简存在一个问题，某些用途的最简式，未必是其他用途的最简式
*** 2.3.3实例：集合的表示
(element-of-set? ele set) 元素ele是否在集合set中
(adjoin-set ele set) 向集合set中增加元素ele
(union-set set1 set2) 合并两个集合set1、set2。
(intersection-set set1 set2) 集合set1、set2的交集。
**** 集合作为未排序的表
并集与交集的处理复杂度约为O(N^2)，有人较真的话O(N*M)，
可这种表示其实是故作聪明。请正确理解复杂度的概念。
**** 集合作为排序的表
为了加速，可以改变集合的表示方式，比如按照升序排列。因为排序之后的表
我们可以分治处理。原来的element-of-set?由O(N)，改为O(logN)
反映到并集、交集计算的时候差异更加明显O(NlogN)
就算不用分治，在计算并集与交集的时候也会有很多优势，
因为不需要两个的全表检查。在递归的时候，可以缩小两个表。
**** 集合作为二叉树
**** 集合与信息检索
现实很复杂，有产品级的需求，有项目级的需求，有演示级的需求，
对应不同的数据量，健壮程度，响应速度，
***  2.3.4 实例：Huffman编码树
**** 定长编码：ASCII
**** 变长编码：莫斯密码，utf-8编码。困难：不知道一个字符的结束
***** 使用间隔符
***** 完整编码不是其他编码的开始（前缀码）
| A |   B |    C |    D |    E |    F |    G |    H |
| 0 | 100 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
一般而言使用变长前缀码处理编码消息，使得长度短的应对频率高，
可以显著的节约空间。一种特定方式就是Huffman编码
***** 一个Huffman树可以表示为一个二叉树
树叶是北面吗的符号，每个非叶子节点表示一个结合，包含其下的所有叶子
并且每个节点有权重，非叶节点为其下所有叶子权重之和。
权重在编码与解码中没用，但是有助于构造树
***** 构造
***** 解码 一个0/1的表与Huffman树为参数
***** 带权重元素的集合
** 2.4 抽象数据的多重表示
关键思想构建一道抽象屏障
在复杂系统里，需要有抽象屏障去隔离互不相同的设计选择
构造通用型过程
*** 2.4.1 复数的表示
**** 直角坐标形式（实部和虚部）
**** 极坐标形式（模与辐角）
*** 2.4.2 带标志数据
**** 最小允诺原则
**** 数据从一个层到另一个层的时候
这种剥去和添加标志的规范方式是一种重要的组织策略
*** 2.4.3 数据导向的程序设计和可加性
上面描述的内容有很多风险问题。主要是需求变更产生的维护需要。
比如增加一种表示方式。
开发过程中的约定也是麻烦，不能有重名过程。
总体来说：不具备可加性。
进一步的方法，一种称为数据导向的程序设计的编程奇数。
使用矩阵方式考虑问题，两种维度：操作维度，数据类型维度
|           | Polar           | Rectangular           |
| real-part | real-part-polar | real-part-rectangular |
| imag-part | imag-part-polar | imag-part-rectangular |
| magnitude | magnitude-polar | magnitude-rectangular |
| angle     | angle-polar     | angle-rectangular     |
增加两个过程put/get
(put <op> <type> <item>)
(get <op> <type>)
安装包过程，
访问操作过程
*** TODO 做完3.3的练习024后，需要重新exp.2.073以及之后的练习。
**** 消息传递
数据导向的程序设计里：关键的想法是通过显示处理操作类型表格的方式。
** 2.5 带有通用型操作的系统
*** 2.5.1 通用型算术运算
*** 2.5.2 不同类型的数据的组合
**** 每一种组合类型提供特定的过程
这种方式确实可以，但是很麻烦。但是阅读与实现很简单。
所以如果波及的内容非常少时，这应该是一个很好的选择。
一些内部过程，个人觉得都是这种思想的体现。
**** 强制
**** 类型的层次结构
***** 类型塔
每一种类型只有至多一个超类型和至多一个子类型
**** 层次结构的不足
***** 处理好一大批相互有关的类型而同时又保持模块性，是非常难的问题。
***** 类型之间的通用操作的处理。很难但是一直在持续研究的领域。
*** 2.5.3 实例：符号代数
**** 多项式算术
* 第三章 模块化、对象和状态
程序的组织原则主要有两种策略
1、对象仿真的方式组织程序
2、信息流加工的方式组织程序
** 3.1 赋值和局部状态
*** 3.1.1局部状态变量
*** 3.1.2引入赋值带来的利益
**** 系统可以看作是一套待有局部变量的对象
*** 3.1.3引入赋值带来的代价
**** 不用赋值的话，同一过程同样参数的两次求值必然产生同样的结果。
***** 不用任何赋值的程序设计称为函数式程序设计
**** 统一和变化
***** 如果在表达式里“同一的东西可以相互替换”称之为具有引用透明性
个人觉得：使用函数式编程的核心收益就是让程序的引用透明性增强。
***** 同一和变化。更多的是程序设计的问题，而不是程序设计语言的问题
**** 命令式程序设计的缺陷
***** 广泛采用赋值的程序设计被称为命令式程序设计。
***** 使用赋值的时候会产生一些陷阱，赋值顺序变化会导致结果变化。
** 3.2 求值的环境模型
*** 将一个符合过程应用于一些实际参数，就是在各个实际参数代换过程体里对应的形式参数后，求值这个过程体
一个环境就是框架（frame）的一个序列，每个框架是包含一些约束的一个表格（可能
为空），这些约束将一些变量名字关联于对应的值（在一个框架里，任何变量至多有
一个约束）。每个框架还包含着一个指针，指向这一个框架的外围环境。如果由于当
前讨论的目的，将相应的框架看作是全局的，那么它将没有外围环境。一个变量相对
于某个特定环境的值，也就是在这一个环境中，包含着改变量的第一个框架里这个变
量的月数值。如果序列中并不存在这一变量的约束，那么我们就说这个变量在该特定
环境中是无约束的。
-- 上面是文章中一段简单的描述。JavaScript的环境与作用域就是采用这种思路处理的。
-- 估计绝大多数的解释类语言可能都是才作用这种策略。
*** 3.2.1 求值规则
**** 整体描述
***** 求值这一组合式的各个子表达式
***** 将运算符子表达式的值应用于运算符对象子表达式的值（不知道在说啥，感觉是翻译的问题）
**** 代换模型->环境模型
***** 将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的实际参数，而后在构造起的新环境的上下文中求值过程体。这个新框架的外围环境就是作为被应用的哪个过程对象的一部分的环境。
***** 相对于一个给定环境求值一个lambda表达式，将创建一个过程对象，过程对象时一个序对，由该lambda表达式的正文和一个指向环境的指针组成。这一指针指向的就是创建这个过程对象的环境。
了解这些综述后再了解ECMAScript-262标准中的一些规范是，就有很好的参考了。
*** 3.2.2 简单过程的应用
**** 用环境模型求值
*** 3.2.3 将框架看作局部状态的展台
**** 方法体与运行环境
*** 3.2.4 内部定义
** 3.3 用变动数据做模拟
选择函数，构造函数之外需要增加改变函数
增加了改变函数的数据对象成为变动数据对象
*** 3.3.1 变动的表结构
**** 基本操作是 set-car! set-cdr!
**** 到目前为止
***** 使用函数式编程的便利是维护性好，缺点是编写麻烦，需要更多的准备工作
***** 使用命令式编程的便利是逻辑直观，缺点是维护性差，容易跟其他业务功能耦合
**** 共享和相等
***** 如果没有赋值，共享就完全不会被察觉
***** 除非很好的理解了数据对象的共享情况，否则使用改变函数就会造成意想不到的结果。
**** 改变也就是赋值。
*** 3.3.2 队列的表示
**** 简单方式->带索引的方式
*** 3.3.3 表格的表示(183)
**** 一维表格:带表头单元的表
**** 两维表格:用两个关键码去提取信息
**** 创建局部的表格
*** 3.3.4 数字电路的模拟器
**** 事件驱动的模拟（怀疑与发布订阅有关）
***** 基本构件：规定行为：输入信号，延迟事件，输出信号
***** 连线：传递信号，扩展：（感应干扰信号）
**** 基本功能块
***** (get-signal <wire>)
***** (set-signal! <wire> <new value>)
***** (add-action! <wire> <procedure of no arguments>)
***** (after-delay)
<<<<<<< HEAD
=======
**** 路线的表示
***** 
>>>>>>> origin/comp
